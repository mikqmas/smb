<html>

    <head>

        <!-- <script src='Box2dWeb.min.js'></script> -->
        <script src="three.min.js"></script>
        <script src="keyboard.js"></script>
        <script src="jquery.js"></script>

        <script>
          var renderer = undefined,
              camera = undefined,
              scene = undefined,
              keyAxis = [0,0],

          // Render
              mazeDimension = 10,


          // Box2D world Vars
              wWorld = undefined,
              wBall = undefined;

          function createPhysics() {
            //world obj
            wWorld = new b2World(new b2Vec2(0,0), true);

            //create ball
            var bodyDef = new b2BodyDef();
            bodyDef.type = b2Body.b2_dynamicBody;
            bodyDef.position.Set(1,1);
            wBall = wWorld.CreateBody(bodyDef);
            var fixDef = new b2FixtureDef();
            fixDef.density = 1.0;
            fixDef.friction = 0.0;
            fixDef.restitution = 0.25;
            fixDef.shape = new b2CircleShape(1);
            wBall.CreateFixture(fixDef);
          }

          function createRender() {
            //Create scene
            scene = new THREE.Scene();

            //add light

            // Add the camera.
            var aspect = window.innerWidth/window.innerHeight;
            camera = new THREE.PerspectiveCamera(60, aspect, 0.1, 1000);
            camera.position.set(1, 1, 5);
            // scene.add(camera);

            // Add the ball.
            g = new THREE.SphereGeometry(1, 32, 32);
            m = new THREE.MeshBasicMaterial({color:0x00ff00, wireframe: true});
            ballMesh = new THREE.Mesh(g, m);
            ballMesh.position.set(0,0,0);

            // Add the player
            // g = new THREE.SphereGeometry(1, 32, 32);
            player = new THREE.Object3D();
            player.position.set(1, 1, 1);
            player.add( camera );
            player.add(ballMesh);
            scene.add(player);

            // Add the ground.
            g = new THREE.PlaneGeometry(mazeDimension*10, mazeDimension*10, mazeDimension, mazeDimension);
            // planeTexture.wrapS = planeTexture.wrapT = THREE.RepeatWrapping;
            // planeTexture.repeat.set(mazeDimension*5, mazeDimension*5);
            // m = new THREE.MeshPhongMaterial({map:planeTexture});
            m = new THREE.MeshBasicMaterial({color: 0x00ff00, wireframe: true})
            planeMesh = new THREE.Mesh(g, m);
            planeMesh.position.set((mazeDimension-1)/2, (mazeDimension-1)/2, 0);
            // planeMesh.rotation.set(Math.PI/2, 0, 0);
            scene.add(planeMesh);

          }

          function updateRender() {
            // console.log(keyAxis);
            // Update ball position.
            player.position.x += keyAxis[0]/10;
            player.position.y += keyAxis[1]/10;

            ballMesh.position.x = player.position.x
            ballMesh.position.y = player.position.y

            camera.position.x = player.position.x
            camera.position.y = player.position.y - 8

            ballMesh.rotateZ( -(keyAxis[0]/10) );
            // ballMesh.rotateX( (keyAxis[1]/1) );
            ballMesh.rotateX( (keyAxis[1]/10) );

            camera.lookAt( player.position );

            var mazeZ = Math.floor(ballMesh.position.z + 0.5);
            console.log(mazeZ);
            if (mazeZ == -5) {
              ballMesh.position.y -= 0.1;
              console.log("YOU WIN!")
            }

            // var tempMat = new THREE.Matrix4();
            // tempMat.makeRotationAxis(new THREE.Vector3(0,1,0), 0.1);
            // tempMat.multiplySelf(ballMesh.matrix);
            // ballMesh.matrix = tempMat;
            // tempMat = new THREE.Matrix4();
            // tempMat.makeRotationAxis(new THREE.Vector3(1,0,0), -0.1);
            // tempMat.multiplySelf(ballMesh.matrix);
            // ballMesh.matrix = tempMat;
            // ballMesh.rotation.getRotationFromMatrix(ballMesh.matrix);

            keyAxis = [0,0];

            // // Update ball rotation.
            // var tempMat = new THREE.Matrix4();
            // tempMat.makeRotationAxis(new THREE.Vector3(0,1,0), stepX/ballRadius);
            // tempMat.multiplySelf(ballMesh.matrix);
            // ballMesh.matrix = tempMat;
            // tempMat = new THREE.Matrix4();
            // tempMat.makeRotationAxis(new THREE.Vector3(1,0,0), -stepY/ballRadius);
            // tempMat.multiplySelf(ballMesh.matrix);
            // ballMesh.matrix = tempMat;
            // ballMesh.rotation.getRotationFromMatrix(ballMesh.matrix);
            //
            // // Update camera and light positions.
            // camera.position.x += (ballMesh.position.x - camera.position.x) * 0.1;
            // camera.position.y += (ballMesh.position.y - camera.position.y) * 0.1;
            // camera.position.z += (5 - camera.position.z) * 0.1;
            // light.position.x = camera.position.x;
            // light.position.y = camera.position.y;
            // light.position.z = camera.position.z - 3.7;
          }


          function onMoveKey(axis) {
            keyAxis = axis.slice(0);
          }

          function gameLoop(){

            updateRender();

            renderer.render(scene, camera);
            requestAnimationFrame(gameLoop);
          }
          $(document).ready(function() {
              // Create the renderer.
              renderer = new THREE.WebGLRenderer();
              renderer.setSize(window.innerWidth, window.innerHeight);
              document.body.appendChild(renderer.domElement);

              createRender();

              // Bind keyboard and resize events.
              KeyboardJS.bind.axis('left', 'right', 'down', 'up', onMoveKey);
              KeyboardJS.bind.axis('h', 'l', 'j', 'k', onMoveKey);

              // Start the game loop.
              gameLoop();
          })
        </script>

        <style>
            body {
                background: black;
                margin: 0;
                padding: 0;
            }
        </style>

    </head>

    <body>
    </body>

</html>
