<html>

    <head>
    <link rel="stylesheet" href="./main.css" media="screen" title="no title" charset="utf-8">
    <script src="https://ajax.googleapis.com/ajax/libs/threejs/r76/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.js"></script>
    <script src="keyboard.js"></script>

        <script>
          var renderer = undefined,
              camera = undefined,
              scene = undefined,
              keyAxis = [0,0],
              keyActions = [0],
              timeStep=1/60,

          // Render
              mazeDimension = 10,
              startTime = 0,
              timer = 0,
              didEnd = false,
              timebox = undefined,
              control = "ball",
              bestTime = "00.00",


          // Cannon world Vars
              world = undefined,
              ball = undefined,
              body = undefined,
              maze = undefined,
              groundBody = undefined;

          function initCannon() {
            //Create World
            world = new CANNON.World();
            world.gravity.set(0,0,-50);
            world.broadphase = new CANNON.NaiveBroadphase();
            world.solver.iterations = 10;

            //Create Ball
            let shape = new CANNON.Sphere(1);
            body = new CANNON.Body({
              mass: 500,
            });
            body.addShape(shape);
            body.position.set(0,-5,14);

            //Create Maze
            const obj = new CANNON.Box(new CANNON.Vec3(4, 10, 2));
            const obj2 = new CANNON.Box(new CANNON.Vec3(10, 4, 2));
            const obj3 = new CANNON.Box(new CANNON.Vec3(4,18,2));
            const obj4 = new CANNON.Box(new CANNON.Vec3(18,4,2));
            const obj5 = new CANNON.Box(new CANNON.Vec3(2,5,2));
            maze = new CANNON.Body({mass: 0});
            maze.addShape(obj);
            maze.addShape(obj2, new CANNON.Vec3( 6, 14, 0));
            maze.addShape(obj3, new CANNON.Vec3( 20, 0, 0));
            maze.addShape(obj4, new CANNON.Vec3( 6, -22, 0));
            maze.addShape(obj5, new CANNON.Vec3(-10, -13, 0));
            maze.position.set(0,0,10);

            //Create Ground
            var groundShape = new CANNON.Plane();
            groundBody = new CANNON.Body({ mass: 0, shape: groundShape });

            //Add bodies
            world.addBody(body);
            world.addBody(groundBody);
            world.addBody(maze);

          }

          function createRender() {
            const loader = new THREE.TextureLoader();
            //Create scene
            scene = new THREE.Scene();

            // Add the camera.
            var aspect = window.innerWidth/window.innerHeight;
            camera = new THREE.PerspectiveCamera(60, aspect, 0.1, 1000);
            camera.position.set(0, -20, 10);
            // scene.add(camera);

            var light = new THREE.AmbientLight( 0x404040 ); // soft white light
            scene.add(light);

            var directionalLight = new THREE.DirectionalLight( 0xffffff, 1 );
            directionalLight.position.set( 2, 5, 15 );
            directionalLight.castShadow= true;
            scene.add( directionalLight );


            // //Curve Test
            // var sampleClosedSpline = new THREE.CatmullRomCurve3([
        		// 	new THREE.Vector3(0, 0, 10),
        		// 	new THREE.Vector3(10, 10, 20),
            //   new THREE.Vector3(-10, 20, 10)
        		// ]);
            //
            // function addTube() {
            //
        		// 	tube = new THREE.TubeGeometry(sampleClosedSpline);
        		// 	addGeometry(tube, 0xff00ff);
        		// 	tubeMesh.scale.set( 1, 1, 1 );
            //   tubeMesh.position.set( 0, 0, 1 );
            //
        		// }
            //
            //
        		// function addGeometry( geometry, color ) {
            //
        		// 	// 3d shape
            //
        		// 	tubeMesh = THREE.SceneUtils.createMultiMaterialObject( geometry, [
        		// 		new THREE.MeshLambertMaterial({
        		// 			color: color
        		// 		}),
        		// 		new THREE.MeshBasicMaterial({
        		// 			color: 0x000000,
        		// 			opacity: 0.3,
        		// 			wireframe: true,
        		// 			transparent: true
        		// 	})]);
            //
        		// 	scene.add( tubeMesh );
            //
        		// }

            // Add the ball.
            var ballTexture = loader.load('ball.png');
            ballTexture.wrapS = ballTexture.wrapT = THREE.RepeatWrapping;
            ballTexture.repeat.set(1,1);

            g = new THREE.SphereGeometry(1, 20, 20);
            m = new THREE.MeshPhongMaterial({map:ballTexture});
            ballMesh = new THREE.Mesh(g, m);
            // ballMesh.position.set(0,0,0);

            // Add the player
            // g = new THREE.SphereGeometry(1, 32, 32);
            // m = new THREE.MeshBasicMaterial({color:0x00ffff, wireframe: true});
            // player = new THREE.Mesh(g, m);
            player = new THREE.Object3D();
            // player.position.set(0, 0, 4);
            player.add( camera );
            player.add(ballMesh);
            scene.add(player);

            //Add the ground.
            // m = new THREE.MeshBasicMaterial({color: 0x00ff00, wireframe: true})

            var planeTexture = loader.load('lab-floor.jpg');
            planeTexture.wrapS = planeTexture.wrapT = THREE.RepeatWrapping;
            planeTexture.repeat.set(20,20);
            m = new THREE.MeshPhongMaterial({map:planeTexture});
            g = new THREE.PlaneGeometry(mazeDimension*20, mazeDimension*20, mazeDimension, mazeDimension);
            planeMesh = new THREE.Mesh(g, m);
            scene.add(planeMesh);
            // let planeTexture = THREE.TextureLoader().load("ball.png");


            // Add the maze
            //overall maze object
            mazeMesh = new THREE.Object3D();
            //texture wrapping
            var mazeTexture = loader.load('brick.png');
            mazeTexture.wrapS = mazeTexture.wrapT = THREE.RepeatWrapping;

            var mazeTexture2 = loader.load('brick.png');
            mazeTexture2.wrapS = mazeTexture2.wrapT = THREE.RepeatWrapping;

            var checkersTexture = loader.load('checker.gif');
            checkersTexture.wrapS = checkersTexture.wrapT = THREE.RepeatWrapping;
            checkersTexture.repeat.set(1, 2);

            mazeTexture.repeat.set(2, 4);
            mazeTexture2.repeat.set(12, 2);

            m = new THREE.MeshPhongMaterial({map:mazeTexture});
            g = new THREE.BoxGeometry(8,20,4);
            obj1Mesh = new THREE.Mesh(g,m)
            mazeMesh.add(obj1Mesh);

            g = new THREE.BoxGeometry(20,8,4);
            m = new THREE.MeshPhongMaterial({map:mazeTexture2});
            obj2Mesh = new THREE.Mesh(g,m);
            obj2Mesh.position.set(6, 14, 0);
            mazeMesh.add(obj2Mesh);
            scene.add(mazeMesh);

            g = new THREE.BoxGeometry(8,36,4);
            m = new THREE.MeshPhongMaterial({map:mazeTexture});
            obj3Mesh = new THREE.Mesh(g,m);
            obj3Mesh.position.set(20, 0, 0);
            mazeMesh.add(obj3Mesh);
            scene.add(mazeMesh);

            g = new THREE.BoxGeometry(36,8,4);
            m = new THREE.MeshPhongMaterial({map:mazeTexture2});
            obj4Mesh = new THREE.Mesh(g,m);
            obj4Mesh.position.set(6, -22, 0);
            mazeMesh.add(obj4Mesh);
            scene.add(mazeMesh);

            g = new THREE.BoxGeometry(4,10,4);
            m = new THREE.MeshPhongMaterial({map:checkersTexture});
            obj5Mesh = new THREE.Mesh(g,m);
            obj5Mesh.position.set(-10, -13, 0);
            mazeMesh.add(obj5Mesh);
            scene.add(mazeMesh);
          }

          function updatePhysics() {
            // Step the physics world
            world.step(timeStep);
            // body.velocity.set(keyAxis[0]*10,keyAxis[1]*10 ,keyActions[0]);
            // planeMesh.rotation.x = 1;
            if(control === "platform") {
              if(keyAxis[0] !== 0 && maze.quaternion.y < 0.2 && maze.quaternion.y > -0.2 ) {
                maze.quaternion.y += keyAxis[0]/500;
              }else {
                if(maze.quaternion.y > -0.005 && maze.quaternion.y < 0.005) {
                  maze.quaternion.y = 0;
                }else if(maze.quaternion.y < 0){
                  maze.quaternion.y += .005;
                }else if(maze.quaternion.y > 0) {
                  maze.quaternion.y -= .005;
                }
              }
              if(keyAxis[1] !== 0 && maze.quaternion.x < 0.2 && maze.quaternion.x > -0.2 ) {
                maze.quaternion.x -= keyAxis[1]/500;
              }else {
                if(maze.quaternion.x >= -0.005 && maze.quaternion.x <= 0.005) {
                  maze.quaternion.x = 0;
                }else if(maze.quaternion.x < 0){
                  maze.quaternion.x += .005;
                }else if(maze.quaternion.x > 0) {
                  maze.quaternion.x -= .005;
                }
              }
            } else {
              body.velocity.x += keyAxis[0]/5;
              body.velocity.y += keyAxis[1]/5;
            }


            // Copy coordinates from Cannon.js to Three.js
            player.position.copy(body.position);
            ballMesh.quaternion.copy(body.quaternion);

            mazeMesh.position.copy(maze.position);
            mazeMesh.quaternion.copy(maze.quaternion);

            // planeMesh.position.copy(groundBody.position);
            // planeMesh.quaternion.copy(groundBody.quaternion);

          }

          function updateRender() {
            camera.quaternion.y = 0;
            camera.quaternion.z = 0;
            camera.quaternion.x = .5;

            keyAxis = [0,0];
            keyActions = [0]
          }

          function updateTimer() {
            //timer counting up from zero
            timer = performance.now()/10 - startTime;

            if(timer < 3000) {
              //timebox counting down from start time ie. 30.00.
              timebox.innerHTML = Math.round((Math.ceil(3000 - timer)/100) * 100)/100;
            }
          }

          function gameOver(why) {
            if(!!document.getElementById('gameover')) {
              return;
            }
            let gameover = document.createElement('div');
            gameover.setAttribute("id", "gameover");
            gameover.innerHTML = why;
            if(why === "winner"){
              gameover.style.width = 300 + "px";
              gameover.style.left = window.innerWidth/2 - 320;
            }else {
              gameover.style.width = 600 + "px";
              gameover.style.left = window.innerWidth/2 - 260;
            }
            gameover.style.top = window.innerHeight/2 - 100;
            timebox.innerHTML = "";
            document.body.appendChild(gameover);

            askRestart();
          }

          function winner() {
            if(!!document.getElementById('gameover')) {
              return;
            }
            didEnd = true;
            let win = document.createElement('div');
            win.setAttribute("id", "gameover");
            win.innerHTML = "Winner";
            win.style.left = window.innerWidth/2 - 70;
            win.style.top = window.innerHeight/2 - 100;
            document.body.appendChild(win);
            askRestart();
            //Append Best Timebox
            const currTime = document.getElementById('timebox').innerHTML;
            bestTime = bestTime < currTime ? currTime : bestTime;
            document.getElementById('bestTime').innerHTML = "Best Time: " + bestTime;
          }

          function askRestart() {
            let reset = document.createElement('div');
            reset.setAttribute("class", "question");
            reset.innerHTML = "Replay?";
            reset.style.left = window.innerWidth/2 - 200;
            reset.style.top = window.innerHeight/2;
            reset.onclick = function() {
              console.log("HERE")
              resetGame(control === "ball" ? "ball" : "platform");
            }
            document.body.appendChild(reset);

            if(control === "ball") {
              let harder = document.createElement('div');
              harder.setAttribute("class", "question");
              harder.innerHTML = "Harder?";
              harder.style.left = window.innerWidth/2 + 50;
              harder.style.top = window.innerHeight/2;
              harder.onclick = function() {
                resetGame("platform");
              }
              document.body.appendChild(harder);
            }

            if(control === "platform") {
              let easier = document.createElement('div');
              easier.setAttribute("class", "question");
              easier.innerHTML = "Easier?";
              easier.style.left = window.innerWidth/2 + 50;
              easier.style.top = window.innerHeight/2;
              easier.onclick = function() {
                resetGame("ball");
              }
              document.body.appendChild(easier);
            }
          }

          function onMoveKey(axis) {
            keyAxis = axis.slice(0);
          }

          function onWindowResize() {
      			windowHalfX = window.innerWidth / 2;
      			windowHalfY = window.innerHeight / 2;

      			camera.aspect = window.innerWidth / window.innerHeight;
      			camera.updateProjectionMatrix();

      			renderer.setSize( window.innerWidth, window.innerHeight );
      		}

          function resetGame(arr) {
            didEnd = false;
            startTime += timer;
            control = arr;
            body.velocity.set(0,0,0);
            body.angularVelocity.set(0,0,0);
            body.position.set(0,-5,14);
            document.body.removeChild(document.getElementById('gameover'));
            const question = document.getElementsByClassName('question');
            document.body.removeChild(question[0]);
            document.body.removeChild(question[0]);
          }

          function gameLoop(){
            if(didEnd === false) {
              updateTimer();
            }
            updatePhysics();
            updateRender();

            if(timer > 3000) {
              gameOver("Time Expired");
            }else if(player.position.z < 1 ) {
              gameOver("Out of Bounds");
            }else if(player.position.z > 12.8 && player.position.z <= 13
                  && player.position.x <= -8 && player.position.x >= -12
                  && player.position.y >= -18 && player.position.y <= -8 ){
                  winner();
            }
            renderer.render(scene, camera);
            requestAnimationFrame(gameLoop);
          }

          document.addEventListener("DOMContentLoaded", () => {
            //Add window resize listener
            window.addEventListener( 'resize', onWindowResize, false );

            // Create the renderer.
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Bind keyboard and resize events.
            KeyboardJS.bind.axis('left', 'right', 'down', 'up', onMoveKey);
            KeyboardJS.bind.axis('h', 'l', 'j', 'k', onMoveKey);
            KeyboardJS.bind.key('spacebar', function() {
                keyActions[0] = 10;
                return false;
            });

            timebox = document.createElement('div');
            timebox.setAttribute("id", "timebox");
            timebox.style.left = window.innerWidth/2 - 10;
            document.body.appendChild(timebox);

            initCannon();
            createRender();

            // Start the game loop.
            gameLoop();
          })
        </script>

    </head>

    <body>
      <div id="bestTime">Best Time:</div>
    </body>

</html>
